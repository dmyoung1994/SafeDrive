//# signalr-client
//By: [Matthew Whited](mailto:matt@whited.us?subject=signalr-client)  (c) 2014

var url = require('url'),
    querystring = require('querystring'),
    http = require('http'),
    WebSocketClient = require('websocket').client; // https://github.com/Worlize/WebSocket-Node

function toCleanHubNames(hubNames){
    var res = [], o = 0;

    if (hubNames.length && hubNames.length > 0) {
        for (var i = 0; i < hubNames.length; i++)
        {
            var p = hubNames[i];
            if (typeof p === "string") {
                res[o++] = { name: p.toLowerCase()};
            }
        }
    }

    return res;
}

function negotiateProxies(baseUrl, hubNames, onSuccess, onError) {

    var cleanedHubs = toCleanHubNames(hubNames);
    if (!cleanedHubs || cleanedHubs.length < 1) {
        onError('you must define at least one hub name and they must be typeof string');
        return;
    }

    var negotiateData = "";
    var negotiateUrl = baseUrl + "/negotiate?" + querystring.stringify({ 
        connectionData: JSON.stringify(cleanedHubs),
        clientProtocol: 1.3
    });
    var negotiateUrlOptions = url.parse(negotiateUrl, true);

    var negotiateResult = http.get(negotiateUrlOptions, function(res) {
        res.on('data', function (chunk) {
            negotiateData += chunk;
        });
        res.on('end', function(endRes) {
            try {
                var negotiateObj = JSON.parse(negotiateData);
                negotiateObj.Hubs = cleanedHubs;
                onSuccess(negotiateObj);
            } catch (e) {
                onError('Parse Error', e, negotiateData);
            }
        });
        res.on('error', function(e) {
                onError('HTTP Error', e);
        });
    });
}

function getBindings(baseUrl, hubNames, onSuccess, onError) {
    negotiateProxies(baseUrl, hubNames, function(negotiatedOptions) {
        
        if (!negotiatedOptions.TryWebSockets) {
            onError('This client only supports websockets', undefined, negotiatedOptions);
            return;
        }

        //negotiatedOptions.Url	                    "/signalr"	        String
        //negotiatedOptions.ProtocolVersion	        "1.2"	            String
        //negotiatedOptions.TryWebSockets	        true	            Boolean
        //negotiatedOptions.ConnectionToken	        "..."	            String
        //negotiatedOptions.ConnectionId	        "..."	            String
        //negotiatedOptions.Hubs                    [{name: "..."}]     Array
        //negotiatedOptions.KeepAliveTimeout	    20	                Number
        //negotiatedOptions.DisconnectTimeout	    30	                Number
        //negotiatedOptions.TransportConnectTimeout	5	                Number

        onSuccess({
            url: baseUrl,
            connection: {
                token: negotiatedOptions.ConnectionToken,
                id: negotiatedOptions.ConnectionId
            },
            timeouts: {
                keepAlive: negotiatedOptions.KeepAliveTimeout,
                disconnect: negotiatedOptions.DisconnectTimeout,
                connect: negotiatedOptions.TransportConnectTimeout
            },
            hubs: negotiatedOptions.Hubs
        });

    }, onError);
}

function getConnectQueryString(_client) {           
    var connectData = "";
    var connectQueryString = _client.url + "/connect?" + querystring.stringify({ 
        transport: "webSockets",
        connectionToken: _client.connection.token,
        connectionData: JSON.stringify(_client.hubData),
        tid: 10
    });
    return connectQueryString;
}

function getArgValues (params) {
    var res = [];

    if (params.length && params.length > 1) {
        for (var i = 1; i < params.length; i++)
        {
            var p = params[i];
            if (typeof p === "function" || typeof p === "undefined") {
                p = null;
            }
            res[i-1] = p;
        }
    }

    return res;
}

function handlerErrors(errorMessage, e, errorData) {
    console.log("Error Message: " + errorMessage);
    console.log("Exception: " + e);
    console.log("Error Data: " + errorData);

    throw errorMessage;
}

var states = {
    connection: {
        unbound: 0,
        bound: 1,
        connecting: 2,
        connected: 3,
        disconnecting: 4,
        disconnected: 5,
        connectFailed: 6,
        errorOccured: 7,
        retryingConnection: 8,
    }
};

function buildPayload(hubName, methodName, args, messageId) {
    var data = {
        H: hubName,
        M: methodName,
        A: args, 
        I: messageId
    };
    var payload = JSON.stringify(data);
    return payload;
};

function clientInterface(baseUrl, hubs, reconnectTimeout){
    var client = this;
    var _client = {
        pub: client,
        url: baseUrl,
        connection: {
            state: states.connection.unbound,
            token: null,
            id: null
        },
        timeouts: {
            keepAlive: 0,
            disconnect: 0,
            connect: 0
        },
        hubs: [],
        hubData: [],
        handlers: {},
        serviceHandlers: {
            bound: undefined,           // void function(){}
            connectFailed: undefined,   // void function(error){}
            connected: undefined,       // void function(connection){}
            disconnected: undefined,    // void function(){}
            onerror: undefined,         // void function(error){}
            messageReceived: undefined, // bool function(message){ return true /* if handled */}
        },

        // https://github.com/Worlize/WebSocket-Node
        websocket: {
            client: new WebSocketClient(),
            connection: null,
            messageid: 0,
            reconnectTimeout: reconnectTimeout || 10,
            reconnectCount: 0
        }
    };

    client.__defineGetter__('url', function() { return _client.url; });
    client.__defineGetter__('state', function() { return _client.connection.state; });
    client.__defineGetter__('handlers', function() { return _client.handlers; });
    client.__defineGetter__('serviceHandlers', function() { return _client.serviceHandlers; });
    client.__defineGetter__('hubs', function() {
        var ret = [], x = 0;
        for(h in _client.hubs) {
            ret[x++] = h;
        }
        return ret;
    });
    client.__defineGetter__('lastMessageId', function() { return _client.websocket.messageId; });
    client.hub = function(hubName) { return _client.hubs[hubName.toLowerCase()]; };
    client.on = function(hubName, methodName, callback) {
        var handler = _client.handlers[hubName.toLowerCase()];
        if (!handler) {
            handler = _client.handlers[hubName.toLowerCase()] = {};
        }
        var method = handler[methodName.toLowerCase()] = callback;
    };
    client.end = function() {
        if ((_client.connection.state == states.connection.connecting
            || _client.connection.state == states.connection.connected)
            && _client.websocket.connection) {
            _client.connection.state = states.connection.disconnecting;
            var connection = _client.websocket.connection;
            _client.websocket.connection = undefined;
            connection.close();
        }
    };
    client.invoke = function(hubName, methodName) {
        var hub = client.hub(hubName);
        if (!hub)
            return;
        var args = getArgValues(arguments);
        return hub.invoke.apply(hub, args);
    };

    _client.invoke = function(_hub, methodName, args) {
        _client.start();

        var payload = buildPayload(_hub.data.name, methodName, args, _client.websocket.messageid++);
        //try to send message to signalR host
        sendPayload(payload);
        return payload;
    };

    function sendPayload(payload) {
        if (_client.websocket.connection) {
            _client.websocket.connection.send(payload);
        } else {
            setImmediate(sendPayload, payload);             
        }
    }
    function scheduleReconnection(isInitalRetry) {
        //Ensure state is still reconnecting
        if (_client.connection.state == states.connection.retryingConnection) {
            if (isInitalRetry) {
                _client.websocket.reconnectCount = 0;
            } else {
                _client.websocket.reconnectCount++;
            }
            var cancelRetry;
            if (_client.serviceHandlers.reconnecting) {
                var retry = {inital: isInitalRetry, count: _client.websocket.reconnectCount};
                cancelRetry = _client.serviceHandlers.reconnecting.apply(client, [retry]);
            } 
            if (!cancelRetry) {
                setTimeout(function() {
                    var connectQueryString = getConnectQueryString(_client); 
                    _client.websocket.client.connect(connectQueryString);
                }, 1000 + _client.websocket.reconnectTimeout);
                return true;
            }
        }
        return false;
    }

    _client.start = function() {
        if (_client.connection.state != states.connection.connecting
            && _client.connection.state != states.connection.connected
            && _client.connection.state != states.connection.retryingConnection) {
            _client.connection.state = states.connection.connecting;

            //connect to websockets
            var connectQueryString = getConnectQueryString(_client); 
            _client.websocket.client.connect(connectQueryString);
            return false;
        }
        return true;
    };

    _client.websocket.client.on('connectFailed', function(error) {
        if (_client.connection.state == states.connection.retryingConnection
            && scheduleReconnection(false)) {
        } else {
            _client.connection.state = states.connection.connectFailed;
            if (_client.serviceHandlers.connectFailed) {
                _client.serviceHandlers.connectFailed.apply(client, [error]);
            }
        }
    });
    _client.websocket.client.on('connect', function(connection) {
        _client.websocket.connection = connection;
        _client.websocket.messageid = 0; //Reset MessageID on new connection

        //Note: check for reconnecting
        if (states.connection.retryingConnection) {
            //Note: reconnected event  
            if (_client.serviceHandlers.reconnected) {
                _client.serviceHandlers.reconnected.apply(client, [connection]);
            } else {
                console.log("Reconnected!");
            }
        } else {   
            if (_client.serviceHandlers.connected) {
                _client.serviceHandlers.connected.apply(client, [connection]);
            } else {
                console.log("Connected!");
            }
        }
        connection.on('error', function(error) {
            _client.websocket.connection = undefined;
            _client.connection.state = states.connection.errorOccured;

            //Note: Add support for automatic retry
            if (error.code == "ECONNRESET"){
                _client.connection.state = states.connection.retryingConnection;
                if (_client.serviceHandlers.connectionLost) {
                    _client.serviceHandlers.connectionLost.apply(client, [error]);
                } else {
                    console.log("Scheduled Reconnection: " + error.toString());
                }

                scheduleReconnection(true);
            } else {
                if (_client.serviceHandlers.onerror) {
                    _client.serviceHandlers.onerror.apply(client, [error]);
                } else {
                    console.log("Connection Error: " + error.toString());
                }
            }
        });
        connection.on('close', function() {
            _client.websocket.connection = undefined; //Release connection on close
            if (_client.connection.state != states.connection.retryingConnection) {
                _client.connection.state = states.connection.disconnected;
            }
            if (_client.serviceHandlers.disconnected) {
                _client.serviceHandlers.disconnected.apply(client);
            }
        });
        connection.on('message', function(message) {
            var handled = false;
            if (_client.serviceHandlers.messageReceived) {
                handled = _client.serviceHandlers.messageReceived.apply(client, [message]);
            } 
            if (!handled) {
                //{"C":"d-8F1AB453-B,0|C,0|D,1|E,0","S":1,"M":[]}
                if (message.type === 'utf8' && message.utf8Data != "{}") {
                    var parsed = JSON.parse(message.utf8Data);

                    //{"C":"d-74C09D5E-B,1|C,0|D,1|E,0","M":[{"H":"TestHub","M":"addMessage","A":["ie","sgds"]}]}
                    if (parsed.M) {
                        for (var i = 0; i < parsed.M.length; i++) {
                            var mesg = parsed.M[i];
                            var hubName = mesg.H.toLowerCase();
                            var handler = _client.handlers[hubName];
                            if (handler) {
                                var methodName = mesg.M.toLowerCase();
                                var method = handler[methodName];
                                if (method) {
                                    var hub = client.hub(hubName)
                                    method.apply(hub, mesg.A);
                                }
                            }
                        }
                    }
                }
            }
        });
    });

    getBindings(baseUrl, hubs, function(bindings) {

        _client.hubData = bindings.hubs;

        //hubs:  
        for(var i = 0; i < bindings.hubs.length; i++){
            var hubData = bindings.hubs[i];
            _client.hubs[hubData.name] = new hubInterface(_client, hubData);
        }

        //timeouts: { keepAlive: disconnect: connect: },
        _client.timeouts.keepAlive = bindings.timeouts.keepAlive;
        _client.timeouts.disconnect = bindings.timeouts.disconnect;
        _client.timeouts.connect = bindings.timeouts.connect;

        //connection: { token: id: },
        _client.connection.state = states.connection.bound;
        _client.connection.id = bindings.connection.id;
        _client.connection.token = bindings.connection.token;
        
        _client.start();

        if (_client.serviceHandlers.bound) {
            _client.serviceHandlers.bound.apply(client);
        }
    }, handlerErrors);
}

function hubInterface(_client, hubData) {
    var hub = this;
    var _hub = {
        pub: hub,
        client: _client,
        data: hubData
    };

    hub.__defineGetter__('name', function() { return _hub.data.name; });
    hub.__defineGetter__('client', function() { return _hub.client.pub; });
    hub.__defineGetter__('handlers', function() { return _hub.client.handlers[_hub.data.name]; });
    hub.invoke = function(methodName) {
        var args = getArgValues(arguments);
        return _hub.client.invoke(_hub, methodName, args);
    };
    hub.on = function(methodName, callback) {
        _hub.client.pub.on(_hub.data.name, methodName, callback);
    };
}

module.exports = {
    client: clientInterface
};